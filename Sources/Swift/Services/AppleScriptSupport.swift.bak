//
//  AppleScriptSupport.swift
//  Hermes
//
//  Modern Swift implementation of AppleScript command handlers
//  Provides scripting bridge compatibility for automation
//

import Cocoa

// MARK: - Playback State Enum

/// Playback states matching iTunes conventions (4-char codes)
@objc enum PlaybackState: Int {
    case stopped = 0x73746F70  // 'stop'
    case playing = 0x706C6179  // 'play'
    case paused  = 0x70617573  // 'paus'
}

// MARK: - Command Classes

/// Play command - Resume playing the current song
@objc(PlayCommand)
class PlayCommand: NSScriptCommand {
    override func performDefaultImplementation() -> Any? {
        guard let playback = MinimalAppDelegate.shared?.playbackController else {
            return NSNumber(value: false)
        }
        return MainActor.assumeIsolated {
            NSNumber(value: playback.play())
        }
    }
}

/// Pause command - Pause the currently playing song
@objc(PauseCommand)
class PauseCommand: NSScriptCommand {
    override func performDefaultImplementation() -> Any? {
        guard let playback = MinimalAppDelegate.shared?.playbackController else {
            return NSNumber(value: false)
        }
        return MainActor.assumeIsolated {
            NSNumber(value: playback.pause())
        }
    }
}

/// Play/Pause toggle command
@objc(PlayPauseCommand)
class PlayPauseCommand: NSScriptCommand {
    override func performDefaultImplementation() -> Any? {
        guard let playback = MinimalAppDelegate.shared?.playbackController else {
            return self
        }
        MainActor.assumeIsolated {
            playback.playpause()
        }
        return self
    }
}

/// Skip command - Skip to the next song
@objc(SkipCommand)
class SkipCommand: NSScriptCommand {
    override func performDefaultImplementation() -> Any? {
        guard let playback = MinimalAppDelegate.shared?.playbackController else {
            return self
        }
        MainActor.assumeIsolated {
            playback.next()
        }
        return self
    }
}

/// Thumbs up command - Like the current song
@objc(ThumbsUpCommand)
class ThumbsUpCommand: NSScriptCommand {
    override func performDefaultImplementation() -> Any? {
        guard let playback = MinimalAppDelegate.shared?.playbackController else {
            return self
        }
        MainActor.assumeIsolated {
            playback.likeCurrent()
        }
        return self
    }
}

/// Thumbs down command - Dislike the current song
@objc(ThumbsDownCommand)
class ThumbsDownCommand: NSScriptCommand {
    override func performDefaultImplementation() -> Any? {
        guard let playback = MinimalAppDelegate.shared?.playbackController else {
            return self
        }
        MainActor.assumeIsolated {
            playback.dislikeCurrent()
        }
        return self
    }
}

/// Raise volume command - Increase playback volume
@objc(RaiseVolumeCommand)
class RaiseVolumeCommand: NSScriptCommand {
    override func performDefaultImplementation() -> Any? {
        guard let playback = MinimalAppDelegate.shared?.playbackController else {
            return self
        }
        MainActor.assumeIsolated {
            let currentVolume = playback.volume
            playback.volume = currentVolume + 7
            print("Raised volume to: \(playback.volume)")
        }
        return self
    }
}

/// Lower volume command - Decrease playback volume
@objc(LowerVolumeCommand)
class LowerVolumeCommand: NSScriptCommand {
    override func performDefaultImplementation() -> Any? {
        guard let playback = MinimalAppDelegate.shared?.playbackController else {
            return self
        }
        MainActor.assumeIsolated {
            let currentVolume = playback.volume
            playback.volume = currentVolume - 7
            print("Lowered volume to: \(playback.volume)")
        }
        return self
    }
}

/// Full volume command - Set volume to maximum
@objc(FullVolumeCommand)
class FullVolumeCommand: NSScriptCommand {
    override func performDefaultImplementation() -> Any? {
        guard let playback = MinimalAppDelegate.shared?.playbackController else {
            return self
        }
        MainActor.assumeIsolated {
            playback.volume = 100
            print("Changed volume to: \(playback.volume)")
        }
        return self
    }
}

/// Mute command - Mute playback, saving current volume
@objc(MuteCommand)
class MuteCommand: NSScriptCommand {
    override func performDefaultImplementation() -> Any? {
        guard let playback = MinimalAppDelegate.shared?.playbackController else {
            return self
        }
        MainActor.assumeIsolated {
            AppleScriptSupport.savedVolume = playback.volume
            playback.volume = 0
            print("Changed volume to: \(playback.volume)")
        }
        return self
    }
}

/// Unmute command - Restore volume to pre-mute level
@objc(UnmuteCommand)
class UnmuteCommand: NSScriptCommand {
    override func performDefaultImplementation() -> Any? {
        guard let playback = MinimalAppDelegate.shared?.playbackController else {
            return self
        }
        MainActor.assumeIsolated {
            playback.volume = AppleScriptSupport.savedVolume
            print("Changed volume to: \(playback.volume)")
        }
        return self
    }
}

/// Tired command - Mark current song as "tired of this song"
@objc(TiredCommand)
class TiredCommand: NSScriptCommand {
    override func performDefaultImplementation() -> Any? {
        guard let playback = MinimalAppDelegate.shared?.playbackController else {
            return self
        }
        MainActor.assumeIsolated {
            playback.tiredOfCurrent()
        }
        return self
    }
}

// MARK: - AppleScript Support Helper

/// Helper class for AppleScript support
@objc class AppleScriptSupport: NSObject {
    /// Saved volume for mute/unmute functionality
    static var savedVolume: Int = 0
}

// MARK: - NSApplication Scripting Extension

/// Extension to NSApplication providing AppleScript properties and methods
extension NSApplication {
    
    // MARK: - Volume
    
    @objc var volume: NSNumber {
        get {
            guard let playback = MinimalAppDelegate.shared?.playbackController else {
                return NSNumber(value: 0)
            }
            return MainActor.assumeIsolated {
                NSNumber(value: playback.volume)
            }
        }
        set {
            guard let playback = MinimalAppDelegate.shared?.playbackController else {
                return
            }
            MainActor.assumeIsolated {
                playback.volume = newValue.intValue
            }
        }
    }
    
    // MARK: - Playback State
    
    @objc var playbackState: Int {
        get {
            guard let playback = MinimalAppDelegate.shared?.playbackController else {
                return PlaybackState.stopped.rawValue
            }
            return MainActor.assumeIsolated {
                guard let playing = playback.playing else {
                    return PlaybackState.stopped.rawValue
                }
                
                if playing.isPaused() {
                    return PlaybackState.paused.rawValue
                }
                
                return PlaybackState.playing.rawValue
            }
        }
        set {
            guard let playback = MinimalAppDelegate.shared?.playbackController else {
                return
            }
            
            MainActor.assumeIsolated {
                switch newValue {
                case PlaybackState.stopped.rawValue, PlaybackState.paused.rawValue:
                    _ = playback.pause()
                case PlaybackState.playing.rawValue:
                    _ = playback.play()
                default:
                    print("Invalid playback state: \(newValue)")
                }
            }
        }
    }
    
    // MARK: - Playback Position & Duration
    
    @objc var playbackPosition: NSNumber {
        guard let playback = MinimalAppDelegate.shared?.playbackController else {
            return NSNumber(value: 0.0)
        }
        
        return DispatchQueue.main.sync {
            guard let playing = playback.playing else {
                return NSNumber(value: 0.0)
            }
            
            var progress: Double = 0.0
            playing.progress(&progress)
            return NSNumber(value: progress)
        }
    }
    
    @objc var currentSongDuration: NSNumber {
        guard let playback = MinimalAppDelegate.shared?.playbackController else {
            return NSNumber(value: 0.0)
        }
        
        return DispatchQueue.main.sync {
            guard let playing = playback.playing else {
                return NSNumber(value: 0.0)
            }
            
            var duration: Double = 0.0
            playing.duration(&duration)
            return NSNumber(value: duration)
        }
    }
    
    // MARK: - Current Station
    
    @objc var currentStation: Station? {
        get {
            guard let playback = MinimalAppDelegate.shared?.playbackController else {
                return nil
            }
            return MainActor.assumeIsolated {
                playback.playing
            }
        }
        set {
            guard let station = newValue,
                  let playback = MinimalAppDelegate.shared?.playbackController else {
                return
            }
            
            MainActor.assumeIsolated {
                // Play the selected station
                playback.playStation(station)
                
                // Refresh stations list through AppState
                Task { @MainActor in
                    // Trigger a refresh of the stations in the UI
                    NotificationCenter.default.post(
                        name: Notification.Name("StationsRefreshRequested"),
                        object: nil
                    )
                }
            }
        }
    }
    
    // MARK: - Stations Array
    
    @objc var stations: [Station] {
        // Access stations from Pandora via MinimalAppDelegate
        guard let delegate = MinimalAppDelegate.shared else {
            return []
        }
        let pandora = delegate.pandora()
        return pandora.stations as? [Station] ?? []
    }
    
    // MARK: - Current Song
    
    @objc var currentSong: Song? {
        guard let playback = MinimalAppDelegate.shared?.playbackController else {
            return nil
        }
        return MainActor.assumeIsolated {
            guard let playing = playback.playing else {
                return nil
            }
            return playing.playingSong
        }
    }
}
